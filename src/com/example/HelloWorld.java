package com.example;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;

public class HelloWorld {

	public static void main(String[] args) {
		HelloWorldPractice obj = new HelloWorldPractice();
//		System.out.println(obj.isValid("()"));
//		System.out.println(obj.isValid("()[]{}"));
//		System.out.println(obj.isValid("(]"));
//		System.out.println(obj.isValid("([)]"));
		// int[][] arr = { { 1, 2 }, { 3 }, { 3 }, {} };

		// obj.allPathsSourceTarget(arr);

		// Input: [10,9,2,5,3,7,101,18]
		// Output: 4
		// Explanation: The longest increasing subsequence is [2,3,7,101], therefore the
		// length is 4.
//
//		int[] nums = { 1, 2, 3, 4 };
//		obj.productExceptSelf(nums);
		// root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

		// obj.pathSum(root, 8);
		// String[] words = { "a", "b", "ba", "bca", "bda", "bdca" };

		// System.out.println(obj.longestStrChain(words));
		// System.out.println(obj.subs("abc", 2).toString());
		// String str =
		// "civilwartestingwhetherthatnaptionoranynartionsoconceivedandsodedicatedcanlongendureWeareqmetonagreatbattlefiemldoftzhatwarWehavecometodedicpateaportionofthatfieldasafinalrestingplaceforthosewhoheregavetheirlivesthatthatnationmightliveItisaltogetherfangandproperthatweshoulddothisButinalargersensewecannotdedicatewecannotconsecratewecannothallowthisgroundThebravelmenlivinganddeadwhostruggledherehaveconsecrateditfaraboveourpoorponwertoaddordetractTgheworldadswfilllittlenotlenorlongrememberwhatwesayherebutitcanneverforgetwhattheydidhereItisforusthelivingrathertobededicatedheretotheulnfinishedworkwhichtheywhofoughtherehavethusfarsonoblyadvancedItisratherforustobeherededicatedtothegreattdafskremainingbeforeusthatfromthesehonoreddeadwetakeincreaseddevotiontothatcauseforwhichtheygavethelastpfullmeasureofdevotionthatweherehighlyresolvethatthesedeadshallnothavediedinvainthatthisnationunsderGodshallhaveanewbirthoffreedomandthatgovernmentofthepeoplebythepeopleforthepeopleshallnotperishfromtheearth";
		// System.out.println(obj.longestPalindrome(str));
//		TreeNode root = new TreeNode(10);
//		root.left = new TreeNode(5);
//		root.right = new TreeNode(-3);
//		root.left.left = new TreeNode(3);
//		root.left.right = new TreeNode(2);
//		root.right.right = new TreeNode(11);
//		root.left.left.left = new TreeNode(3);
//		root.left.left.right = new TreeNode(-2);
//		root.left.right.left = new TreeNode(1);
//
//		obj.lowestCommonAncestor(root, null, null);

		// [5,null,14,10,77,null,null,null,95,null,null]
		// 4
		// String[] str=["a","b","ba","bca","bda","bdca"}
		// obj.longestStrChain(words);
		// System.out.println(obj.longestPalindromeSubseq("bbbab"));
		// int[] candidates = { 2, 3, 6, 7 };
		// List<List<Integer>> result = obj.combinationSum(candidates, 7);
		// System.out.println(obj.compareVersion("0.1", "1.1"));

		// char[][] board = { { 'X', 'X', 'X', 'X' }, { 'X', 'O', 'O', 'X' }, { 'X',
		// 'X', 'O', 'X' },
		// { 'X', 'O', 'X', 'X' }, };
		// obj.solve(board);

//		char[][] board = { { 'o', 'a', 'a', 'n' }, { 'e', 't', 'a', 'e' }, { 'i', 'h', 'k', 'r' },
//				{ 'i', 'f', 'l', 'v' } };
//		String[] words = { "oath", "pea", "eat", "rain" };
//
//		List<String> result = obj.findWords(board, words);
//		System.out.println(result.size());
		// int[] nums = { 3, 2, 10, 4 };
		// List<List<Integer>> res = obj.permute(nums);
		// obj.stoneGame2(nums);

		// int[] nums = { 8, 2, 4, 7 };
		// System.out.println(obj.longestSubarray(nums, 4));
		// String[] folders = { "/a", "/a/b/c", "/a/b/d" };
		// obj.removeSubfolders(folders);
		// Input: root = [1,2,3,null,null,4,5]
//
//		TreeNode root = new TreeNode(1);
//		root.left = new TreeNode(2);
//		root.right = new TreeNode(3);
//		root.right.left = new TreeNode(4);
//		root.right.right = new TreeNode(5);
//		Codec codec = new Codec();
//		String result = codec.serialize(root);
//		TreeNode node = codec.deserialize(result);
//		System.out.println(node.val);
//		int[][] a = { { 1, 2 }, { 3, 5 }, { 6, 7 }, { 8, 10 }, { 12, 16 } };
//		int[] b = { 4, 8 };
//		int[][] result = obj.insert(a, b);
		// [[1,2],[3,10],[12,16]]

		// int[][] grid = { { 1, 3, 1 }, { 1, 5, 1 }, { 4, 2, 1 } };
		// int[][] grid = { { 0, 1, 2 } };
		// System.out.println(obj.minPathSum(grid));

		// System.out.println(obj.calculate("3+2*2"));

		// System.out.println(obj.lengthOfLongestSubstring("pwwkew"));
		// System.out.println(obj.lengthOfLongestSubstring("dvdf"));

		// System.out.println(obj.removeKdigits("1432219", 3));

		// System.out.println(obj.longestPalindrome("babad"));
		// System.out.println(obj.makeChange(10));

//		ListNode node = new ListNode(1);
//		node.next = new ListNode(2);
//		node.next.next = new ListNode(3);
//		node.next.next.next = new ListNode(4);
//		node.next.next.next.next = new ListNode(5);
//
//		ListNode result = obj.removeNthFromEnd(node, 1);

		// Java8, Spring ,Design Patterns, DSA
		/*
		 * 3 / \ 9 20 / \ 15 7
		 * 
		 */
		// TreeNode root = new TreeNode();
//		root.left = new TreeNode(9);
//		root.right = new TreeNode(20);
//		root.right.left = new TreeNode(15);
//		root.right.right = new TreeNode(7);
		// List<List<Integer>> res = obj.zigzagLevelOrder(root);
		// obj.lengthOfLongestSubstring("abcabcbb");
		//obj.lengthOfLongestSubstring("pwwkew");
		int[] arr= {4,5,6,7,0,1,2};
		obj.search(arr, 0);
	}

}

class HelloWorldPractice {

	 public ListNode removeNthFromEnd(ListNode head, int n) {
	     
		 return null;
	    }
	/*
	 * Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4
	 * 
	 */
	public int search(int[] nums, int target) {

		if (nums == null || nums.length == 0)
			return -1;
		int low = 0, high = nums.length - 1;
		while (low < high) {
			int mid = (high - low) / 2 + low;
			if (nums[mid] >= nums[high]) {
				low = mid + 1;
			} else {
				high = mid;
			}
		}
		int start = low;
		low = 0;
		high = nums.length - 1;
		if (target >= nums[start] && target <= nums[high]) {
			low = start;
		} else {
			high = start;
		}

		while (low <= high) {
			int mid = (high - low) / 2 + low;
			if (nums[mid] == target) {
				return mid;
			} else if (nums[mid] > target) {
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return -1;
	}

	public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

		ListNode dummy = new ListNode(0);
		ListNode p = l1, q = l2, curr = dummy;
		int carry = 0;

		while (p != null && q != null) {
			int sum = 0;
			int x = p != null ? p.val : 0;
			int y = q != null ? q.val : 0;
			sum = carry + x + y;
			carry = sum / 10;
			curr = new ListNode(sum % 10);
			curr = curr.next;
			if (p != null)
				p = p.next;
			if (q != null)
				q = q.next;

		}
		if (carry > 0) {
			curr.next = new ListNode(carry);
		}

		return dummy.next;
	}

	/*
	 * 
	 * Input: s = "pwwkew" Output: 3 Explanation: The answer is "wke", with the
	 * length of 3. Notice that the answer must be a substring, "pwke" is a
	 * subsequence and not a substring.
	 */
	public int lengthOfLongestSubstring(String s) {

		if (s == null || s.length() == 0)
			return 0;
		int max = Integer.MIN_VALUE, start = 0;
		Set<Character> set = new HashSet<>();
		for (int i = 0; i < s.length(); i++) {
			if (!set.contains(s.charAt(i))) {
				set.add(s.charAt(i));
				if (set.size() > max) {
					max = set.size();
				}
			} else {
				while (s.charAt(start) != s.charAt(i)) {
					set.remove(s.charAt(start));
					start++;
				}
				start++;
			}
		}
		return max;
	}

	public String longestPalindrome(String s) {

		if (s == null || s.length() == 0)
			return null;
		if (s.length() > 1000)
			return "";
		for (int len = s.length(); len > 0; len--) {

			int start = 0;
			int end = len;
			while (end <= s.length()) {
				if (isPalindrome(s.substring(start, end)))
					return s.substring(start, end);
				start++;
				end++;
			}
		}
		return null;
	}

	private boolean isPalindrome(String s) {
		int start = 0, end = s.length() - 1;
		while (start < end) {
			if (s.charAt(start) != s.charAt(end))
				return false;
			start++;
			end--;
		}
		return true;
	}

	public boolean isValidBST(TreeNode root) {

		if (root == null) {
			return true;
		}

		if (root.left != null && !(root.left.val < root.val)) {
			return false;
		}
		if (root.right != null && !(root.right.val > root.val)) {
			return false;
		}
		return isValidBST(root.left) && isValidBST(root.right);

	}

	public List<List<Integer>> allPathsSourceTarget1(int[][] graph) {

		if (graph == null || graph.length == 0)
			return null;

		List<List<Integer>> result = new ArrayList<>();
		allPaths(graph, 0, graph.length - 1, new ArrayList<>(), result);

		return result;
	}

	private void allPaths(int[][] graph, int source, int destination, List<Integer> list, List<List<Integer>> result) {
		if (source == destination) {
			result.add(list);
		}
		list.add(source);
		for (int vertex : graph[source]) {
			List<Integer> copiedList = new ArrayList<>(list);
			allPaths(graph, vertex, destination, copiedList, result);
		}
	}

	public List<List<Integer>> zigzagLevelOrder(TreeNode root) {

		List<List<Integer>> res = new ArrayList<List<Integer>>();
		if (root == null)
			return res;
		Queue<TreeNode> q = new LinkedList<TreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			List<Integer> tmp = new ArrayList<Integer>();
			int size = q.size();
			for (int i = 0; i < size; i++) {
				TreeNode node = q.poll();
				tmp.add(node.val);
				if (node.left != null)
					q.add(node.left);
				if (node.right != null)
					q.add(node.right);
			}
			if (res.size() % 2 == 1)
				Collections.reverse(tmp);
			res.add(tmp);
		}
		return res;
	}

	/*
	 * Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3 Output:
	 * true
	 */
	public boolean searchMatrix(int[][] matrix, int target) {
		if (matrix == null || matrix.length == 0)
			return false;
		int row = matrix.length;
		int col = matrix[0].length;
		int i = 0, j = col - 1;

		while (i < row && j >= 0) {
			if (matrix[i][j] == target) {
				return true;
			} else if (matrix[i][j] < target) {
				i++;
			} else {
				j--;
			}
		}

		return false;
	}

	/*
	 * Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word
	 * = "SEE" Output: true
	 * 
	 */
	public boolean exist(char[][] board, String word) {
		if (word == null || word.length() == 0)
			return false;
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				if (board[i][j] == word.charAt(0) && found(board, i, j, word, 0)) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean found(char[][] board, int i, int j, String word, int index) {
		if (index == word.length()) {
			return true;
		}
		if (i >= board.length || i < 0 || j >= board[i].length || j < 0 || board[i][j] != word.charAt(index)) {
			return false;
		}
		char temp = board[i][j];
		board[i][j] = ' ';

		boolean found = found(board, i - 1, j, word, index + 1) || found(board, i + 1, j, word, index + 1)
				|| found(board, i, j - 1, word, index + 1) || found(board, i, j + 1, word, index + 1);
		board[i][j] = temp;
		return found;
	}

//	Input: nums = [4,5,6,7,0,1,2], target = 0
//			Output: 4
//			Example 2:
//
//			Input: nums = [4,5,6,7,0,1,2], target = 3
//			Output: -1

	public ListNode removeNthFromEnd11(ListNode head, int n) {
		ListNode temp = head;
		int count = 0;
		while (temp != null) {
			temp = temp.next;
			count++;
		}
		if (count == n)
			return head.next;
		else {
			int diff = count - n;
			ListNode prev = null;
			ListNode curr = head;
			for (int i = 0; i < diff; i++) {
				prev = curr;
				curr = curr.next;
			}
			prev.next = curr.next;
			return head;
		}

	}

	/*
	 * Input: s = "()[]{}" Output: true
	 */
	public boolean isValid(String s) {
		if (s == null || s.length() == 0) {
			return false;
		}
		char[] vals = new char[s.length()];
		int j = 0;
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			if (i == 0 && c == ')' || c == '}' || c == ']')
				return false;
			if (c == '(') {
				vals[j++] = ')';
			}
			if (c == '{') {
				vals[j++] = '}';
			}
			if (c == '[') {
				vals[j++] = ']';
			}
			if (c == ')' && c != vals[--j]) {
				return false;
			}
			if (c == '}' && c != vals[--j]) {
				return false;
			}
			if (c == ']' && c != vals[--j]) {
				return false;
			}
		}

		return true;
	}

	public class Item {
		int weight;
		int value;
	}

	// be sparse
	public int knapsack(Item[] items, int W) {
		// Map: i -> W -> value
		Map<Integer, Map<Integer, Integer>> cache = new HashMap<Integer, Map<Integer, Integer>>();
		return knapsack(items, W, 0, cache);
	}

	// Overloaded recursive function
	private int knapsack(Item[] items, int W, int i, Map<Integer, Map<Integer, Integer>> cache) {
		if (i == items.length)
			return 0;
		// Check if the value is in the cache
		if (!cache.containsKey(i))
			cache.put(i, new HashMap<Integer, Integer>());
		Integer cached = cache.get(i).get(W);
		if (cached != null)
			return cached;
		// Compute the item and add it to the cache
		int toReturn;
		if (W - items[i].weight < 0) {
			toReturn = knapsack(items, W, i + 1, cache);
		} else {
			toReturn = Math.max(knapsack(items, W - items[i].weight, i + 1, cache) + items[i].value,
					knapsack(items, W, i + 1, cache));
		}
		cache.get(i).put(W, toReturn);
		return toReturn;
	}

	// Naive brute force solution. Recursively
	// include or exclude each item to try every
	// possible combination
	public int knapsack1(Item[] items, int W) {
		return knapsack1(items, W, 0);
	}

	// Overloaded recursive function
	private int knapsack1(Item[] items, int W, int i) {
		// If we've gone through all the items,
		// return
		if (i == items.length)
			return 0;
		// If the item is too big to fill the
		// remaining space, skip it
		if (W - items[i].weight < 0)
			return knapsack1(items, W, i + 1);
		// Find the maximum of including and not
		// including the current item
		return Math.max(knapsack1(items, W - items[i].weight, i + 1) + items[i].value, knapsack1(items, W, i + 1));
	}

	int[] coins = new int[] { 10, 6, 1 };

	public int makeChange(int c) {
		int[] cache = new int[c + 1];
		for (int i = 1; i <= c; i++) {
			int minCoins = Integer.MAX_VALUE;
			// Try removing each coin from the total
			// and see which requires the fewest
			// extra coins
			for (int coin : coins) {
				if (i - coin >= 0) {
					int currCoins = cache[i - coin] + 1;
					if (currCoins < minCoins) {
						minCoins = currCoins;
					}
				}
			}
			cache[i] = minCoins;
		}
		return cache[c];
	}

	/*
	 * Input: head = [1], n = 1 Output: [] Input: head = [1,2,3,4,5], n = 2 Output:
	 * [1,2,3,5]
	 */
	public ListNode removeNthFromEnd1(ListNode head, int n) {

		ListNode node = head, temp = head;
		int count = 0;
		while (temp != null) {
			count++;
			temp = temp.next;
		}
		if (count == n) {
			return new ListNode();
		}

		int index = count - n;
		count = 0;
		while (node != null) {
			count++;
			if (index == count) {
				head.next = head.next.next;
			}
			node = node.next;

		}
		return head;
	}

	public String simplifyPath(String path) {

		if (path == null || path.length() == 0) {
			return "";
		}
		Stack<String> st = new Stack<>();

		String[] arr = path.split("/");
		for (String str : arr) {
			if (str.equals("/") || str.equals(".")) {
				continue;
			} else if (str.equals("..")) {
				st.pop();
			} else {
				st.push(str);
			}
		}
		StringBuilder result = new StringBuilder();
		for (String s : st) {
			result.append("/");
			result.append(s);
		}
		if (result.toString().length() == 0) {
			return "/";
		} else {
			return result.toString();
		}
	}

	/*
	 * 
	 * Input: s = "babad" Output: "bab" Note: "aba" is also a valid answer.
	 */
	public String longestPalindrome11(String s) {

		int len = s.length();
		if (len > 1000) {
			return "";
		}
		for (len = s.length(); len > 0; len--) {
			int start = 0;
			int end = len;
			while (end <= s.length()) {
				if (isPalindrome(s.substring(start, end))) {
					return s.substring(start, end);
				}
				start++;
				end++;
			}
		}
		return "";
	}

	private boolean isPalindrome1(String str) {
		StringBuilder strBuilder = new StringBuilder(str);
		return strBuilder.reverse().toString().equals(str);
	}

	/*
	 * 
	 * 
	 * Can a tree like data Structure be automated to form groups of members based
	 * on similar data response
	 * 
	 * yes it can be achievable using tries
	 * 
	 */

	public int[][] updateMatrix(int[][] matrix) {

		int m = matrix.length;
		int n = matrix[0].length;

		Queue<int[]> queue = new LinkedList<>();
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 0) {
					queue.offer(new int[] { i, j });
				} else {
					matrix[i][j] = Integer.MAX_VALUE;
				}
			}
		}

		int[] dirs = { -1, 0, 1, 0, -1 };

		while (!queue.isEmpty()) {
			int[] cell = queue.poll();
			for (int i = 0; i < 4; i++) {
				int r = cell[0] + dirs[i];
				int c = cell[1] + dirs[i + 1];
				if (r < 0 || r >= m || c < 0 || c >= n || matrix[r][c] <= matrix[cell[0]][cell[1]] + 1)
					continue;
				queue.add(new int[] { r, c });
				matrix[r][c] = matrix[cell[0]][cell[1]] + 1;
			}
		}

		return matrix;
	}

	/*
	 * Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three
	 * digits 4, 3, and 2 to form the new number 1219 which is the smallest.
	 * 
	 */
	public String removeKdigits(String num, int k) {

		if (num.length() == k) {
			return "0";
		}
		StringBuilder sb = new StringBuilder(num);

		for (int j = 0; j < k; j++) {

			int i = 0;
			while (i < sb.length() - 1 && sb.charAt(i) <= sb.charAt(i + 1)) {
				i++;
			}
			sb.delete(i, i + 1);
		}

		// remove leading 0's
		while (sb.length() > 1 && sb.charAt(0) == '0')
			sb.delete(0, 1);

		if (sb.length() == 0) {
			return "0";
		}

		return sb.toString();

	}

	int val = 0;

	public int longestUnivaluePath(TreeNode root) {
		countUnivaluePath(root);
		return val;
	}

	private void countUnivaluePath(TreeNode root) {
		if (root == null) {
			return;
		}
		if (root.right != null && root.val == root.right.val) {
			val++;
		}
		if (root.left != null && root.val == root.left.val) {
			val++;
		}
		countUnivaluePath(root.left);
		countUnivaluePath(root.right);

	}

	/*
	 * Input: s = "pwwkew" Output: 3 Explanation: The answer is "wke", with the
	 * length of 3. Notice that the answer must be a substring, "pwke" is a
	 * subsequence and not a substring.
	 */
	public int lengthOfLongestSubstring1(String s) {

		Set<Character> set = new HashSet<>();
		int max = 0, start = 0;
		for (int i = 0; i < s.length(); i++) {
			if (!set.contains(s.charAt(i))) {
				set.add(s.charAt(i));
				if (max < set.size()) {
					max = set.size();
				}
			} else {
				while (s.charAt(start) != s.charAt(i)) {
					set.remove(s.charAt(start));
					start++;
				}
				start++;
			}
		}

		return max;
	}

//	Input: "3+2*2"
//		Output: 7
//	Input: " 3+5 / 2 "
//		Output: 5

	public int calculate(String s) {

		List<Character> list = new ArrayList<>();
		int sum = 0;
		if (s == null || s.length() == 0) {
			return 0;
		}
		boolean flag = false;
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '*' || s.charAt(i) == '/') {
				flag = true;
			}
		}
		if (!flag)
			return Integer.parseInt(s);

		for (int i = s.length() - 1; i >= 0; i--) {
			if (s.charAt(i) == ' ') {
				continue;
			}
			list.add(s.charAt(i));
			if (list.size() == 3) {
				int result = 0;
				int val1 = list.get(0) - '0';
				char c = list.get(1);
				int val2 = list.get(2) - '0';
				if (c == '+') {
					result = val1 + val2;
				} else if (c == '-') {
					result = val2 - val1;
				} else if (c == '/') {
					result = val2 / val1;
				} else {
					result = val1 * val2;
				}

				list = null;
				sum = result;
				list = new ArrayList<>();
				char val = (char) (result + '0');
				list.add(val);
			}
		}
		return sum;
	}

	public boolean canJump(int[] nums) {

		if (nums == null || nums.length == 0) {
			return false;
		}
		for (int i = 0; i < nums.length;) {
			if (nums[i] == 0) {
				return false;
			} else {
				i = i + 1;
			}
		}

		return true;
	}

	public int numIslands(char[][] grid) {
		if (grid == null || grid.length == 0) {
			return 0;
		}
		int islands = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j] == '1') {
					islands += numIslands(grid, i, j);
				}
			}
		}
		return islands;
	}

	private int numIslands(char[][] grid, int i, int j) {
		if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == '0') {
			return 0;
		}
		grid[i][j] = '0';
		numIslands(grid, i + 1, j);
		numIslands(grid, i - 1, j);
		numIslands(grid, i, j + 1);
		numIslands(grid, i, j - 1);

		return 1;
	}

	public boolean isValidSudoku(char[][] board) {
		if (board == null || board.length == 0) {
			return false;
		}
		int row = board.length, col = board[0].length;

		return false;

	}

	HashMap<Integer, Integer> map1 = new HashMap();

	public int numTrees(int n) {

		if (n == 0 || n == 1)
			return 1;
		if (map1.containsKey(n))
			return map1.get(n);
		int count = 0;
		for (int i = 1; i <= n; i++)
			count += numTrees(i - 1) * numTrees(n - i);
		map1.put(n, count);

		return map1.get(n);

	}

	public int minPathSum(int[][] grid) {
		if (grid == null || grid.length == 0) {
			return 0;
		}
		int sum = 0;
		if (grid.length == 1) {
			if (grid[0].length == 0) {
				for (int i = 0; i < grid.length; i++) {
					sum += grid[i][0];
				}
			} else {
				for (int i = 0; i < grid[0].length; i++) {
					sum += grid[0][i];
				}
			}

			return sum;
		}

		int i = 0, j = 0;

		return totalMinSum(grid, i, j, sum);

	}

	private int totalMinSum(int[][] grid, int i, int j, int sum) {

		if (i == grid.length - 1 || j == grid[i].length - 1) {
			return sum + grid[i][j];
		}
		sum += Math.min(grid[i + 1][j], grid[i][j + 1]);

		return Math.min(totalMinSum(grid, i + 1, j, grid[i][j] + sum), totalMinSum(grid, i, j + 1, grid[i][j] + sum));

	}

	/// Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
	// Output: [[1,5],[6,9]]
	// [[1,2],[3,5],[6,7],[8,10],[12,16]]
	// [4,8]
	public int[][] insert2(int[][] intervals, int[] newInterval) {

		List<int[]> out = new ArrayList<>();
		int i = 0;

		/*
		 * Step 1. Add all intervals before newInterval (that don't overlap with
		 * newInterval so just 1 in this case 1. 2. 3. 4. 5 ----- ------- ---- --------
		 * ------ -------------
		 */
		while (i < intervals.length && intervals[i][1] < newInterval[0]) {
			out.add(intervals[i++]);
		}

		//
		/*
		 * Step 2. Now i is at an interval that we merge with OR that we don't merge
		 * with (case B) Case A. 1. 2. 3. 4. 5 ----- ------- ---- -------- ------
		 * -------------
		 * 
		 * Case B. 1. 2. ----- ------ -------------
		 * 
		 * "intervals[i][0] <= newInterval[1]" below means if the current interval's
		 * start is before or at the newIntervals end, it should be part of the merge
		 * interval. Look at the diagram, in case A it is easy to see 4. is the last
		 * interval we take. In case B. there are no intervals so the while never loops
		 */
		while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
			newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
			newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
			i++;
		}

		// Add the insert interval
		out.add(newInterval);

		// Step 3. Add all of the intervals that come after the inserted interval if any
		while (i < intervals.length) {
			out.add(intervals[i++]);
		}

		return out.toArray(new int[out.size()][2]);
	}

	public int[][] insert(int[][] intervals, int[] newInterval) {

		List<int[]> res = new ArrayList<>();
		if (intervals == null || intervals.length == 0) {
			res.add(newInterval);
			return res.toArray(new int[1][2]);
		}
		PriorityQueue<int[]> queue = new PriorityQueue<>(
				(int[] a, int[] b) -> (Integer.compare(a[0], b[0]) == 0) ? Integer.compare(a[1], b[1])
						: Integer.compare(a[0], b[0]));
		queue.offer(newInterval);
		for (int[] interval : intervals) {
			queue.offer(interval);
		}

		while (!queue.isEmpty()) {
			int[] pop = queue.poll();
			int[] peek = queue.peek();

			while (!queue.isEmpty() && peek[0] <= pop[1]) {
				pop[0] = Math.min(pop[0], peek[0]);
				pop[1] = Math.max(pop[1], peek[1]);
				queue.poll();
				peek = queue.peek();
			}
			res.add(pop);
		}
		return res.toArray(new int[res.size()][2]);
	}

	public int[][] insert1(int[][] intervals, int[] newInterval) {
		List<Integer> intrvals = new ArrayList<>();
		List<Integer> blacklisted = new ArrayList<>();
		if (intervals == null || intervals.length == 0) {
			int[][] res = { newInterval };
			return res;
		}
		for (int i = 0; i < intervals.length; i++) {
			boolean flag = false;
			if (newInterval[0] <= intervals[i][0] && intervals[i][0] <= newInterval[1]) {
				flag = true;
			}

			if (newInterval[0] <= intervals[i][1] && intervals[i][1] <= newInterval[1]) {
				flag = true;
			}

			if (flag) {
				intrvals.add(intervals[i][0]);
				intrvals.add(intervals[i][1]);
				blacklisted.add(i);
			}
		}

		intrvals.add(newInterval[0]);
		intrvals.add(newInterval[1]);

		// max
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < intrvals.size(); i++) {
			if (max < intrvals.get(i)) {
				max = intrvals.get(i);
			}
		}
		// min
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < intrvals.size(); i++) {
			if (min > intrvals.get(i)) {
				min = intrvals.get(i);
			}
		}
		List<int[]> result = new ArrayList<>();

		int count = 0;
		for (int i = 0; i < intervals.length; i++) {
			if (blacklisted.get(0) == i) {
				result.get(count)[0] = min;
				result.get(count)[1] = max;
			} else if (blacklisted.contains(i)) {
				continue;
			} else {
				result.get(count)[0] = intervals[i][0];
				result.get(count)[1] = intervals[i][1];
			}
			count++;
		}

		return result.toArray(new int[result.size()][]);
	}

	public int longestIncreasingPath(int[][] matrix) {

		return 0;
	}

	/*
	 * Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive
	 * elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
	 * 
	 * 
	 * 
	 */
	public int longestConsecutive(int[] nums) {

		Arrays.sort(nums);
		int count = 1, max = 1;
		for (int i = 0; i + 1 < nums.length; i++) {
			if (nums[i] == nums[i + 1]) {
				count++;
				max = Math.max(max, count);
			} else {
				count = 1;
			}
		}

		return max;
	}

	// Input: "babad"
	// Output: "bab"
	// Note: "aba" is also a valid answer.

	// Input: nums = [-1,0,1,2,-1,-4]
	// Output: [[-1,-1,2],[-1,0,1]]
	public List<List<Integer>> threeSum(int[] nums) {

		Arrays.sort(nums);
		int previousVal = Integer.MIN_VALUE;
		List<List<Integer>> result = new ArrayList<>();
		for (int i = 0; i < nums.length; i++) {
			int right = nums.length - 1;
			int left = i + 1;
			int previous = Integer.MIN_VALUE;
			while (left < right && nums[i] != previousVal) {
				int sum = nums[i] + nums[left] + nums[right];
				if (sum == 0 && nums[left] != previous) {
					List<Integer> list = new ArrayList<>();
					list.add(nums[i]);
					list.add(nums[left]);
					list.add(nums[right]);
					result.add(list);
					previous = nums[left++];
					right--;
				} else if (sum > 0)
					right--;
				else
					previous = nums[left++];
			}
			previousVal = nums[i];
		}

		return result;

	}

	public List<List<Integer>> threeSum1(int[] nums) {
		Arrays.sort(nums);

		List<List<Integer>> tripletList = new LinkedList<>();

		int previousRoot = Integer.MIN_VALUE;
		for (int i = 0; i < nums.length; i++) {
			int left = i + 1;
			int right = nums.length - 1;

			int previous = Integer.MIN_VALUE;

			while (left < right && nums[i] != previousRoot) {

				int sum = nums[i] + nums[left] + nums[right];

				if (sum == 0 && nums[left] != previous) {
					LinkedList<Integer> triplets = new LinkedList<>();
					triplets.add(nums[i]);
					triplets.add(nums[left]);
					triplets.add(nums[right]);
					tripletList.add(triplets);

					previous = nums[left++];
					right--;
				} else if (sum > 0)
					right--;
				else
					previous = nums[left++];
			}
			previousRoot = nums[i];
		}

		return tripletList;
	}

	static class Tries {
		boolean word = false;
		Tries[] children = new Tries[27];
	}

	Tries root = new Tries();

	private boolean add(String s) {
		Tries current = root;
		for (int i = 0; i < s.length(); i++) {
			int charIndex = s.charAt(i) == '/' ? 26 : s.charAt(i) - 'a';
			Tries child = current.children[charIndex];
			if (child == null) {
				current.children[charIndex] = new Tries();
				current = current.children[charIndex];
			} else if (child.word && (i + 1 == s.length() || s.charAt(i + 1) == '/')) {
				return false;
			} else {
				current = child;
			}
		}
		current.word = true;
		return true;
	}

	public List<String> removeSubfolders(String[] folder) {
		Map<Integer, List<String>> lengthToWords = new HashMap<>();
		for (String f : folder) {
			lengthToWords.computeIfAbsent(f.length(), k -> new LinkedList<>()).add(f);

		}
		List<String> result = new LinkedList<>();
		for (int i = 2; i <= 100; i++) {
			for (String word : lengthToWords.getOrDefault(i, Collections.emptyList())) {
				if (add(word)) {
					result.add(word);
				}
			}
		}
		return result;
	}

	public int uniquePathsWithObstacles(int[][] obstacleGrid) {

		int R = obstacleGrid.length;
		int C = obstacleGrid[0].length;

		// If the starting cell has an obstacle, then simply return as there would be
		// no paths to the destination.
		if (obstacleGrid[0][0] == 1) {
			return 0;
		}

		// Number of ways of reaching the starting cell = 1.
		obstacleGrid[0][0] = 1;

		// Filling the values for the first column
		for (int i = 1; i < R; i++) {
			obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
		}

		// Filling the values for the first row
		for (int i = 1; i < C; i++) {
			obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
		}

		// Starting from cell(1,1) fill up the values
		// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]
		// i.e. From above and left.
		for (int i = 1; i < R; i++) {
			for (int j = 1; j < C; j++) {
				if (obstacleGrid[i][j] == 0) {
					obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
				} else {
					obstacleGrid[i][j] = 0;
				}
			}
		}

		// Return value stored in rightmost bottommost cell. That is the destination.
		return obstacleGrid[R - 1][C - 1];
	}

	public Node connect(Node root) {

		return null;
	}

	public int longestSubarray(int[] nums, int limit) {

		if (nums.length == 0)
			return 0;
		PriorityQueue<Integer> minHeap = new PriorityQueue<>();
		PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
		int i = 0;
		int j = 0;
		int result = 1;
		minHeap.offer(nums[i]);
		maxHeap.offer(nums[j]);
		while (j < nums.length) {
			int diff = maxHeap.peek() - minHeap.peek();
			if (diff <= limit) {
				if (j - i + 1 > result)
					result = j - i + 1;
				j++;
				if (j < nums.length) {
					minHeap.offer(nums[j]);
					maxHeap.offer(nums[j]);
				}
			} else {
				minHeap.remove(nums[i]);
				maxHeap.remove(nums[i]);
				i++;
			}

		}
		return result;
	}

	public int[] dailyTemperatures(int[] t) {
		int[] arr = new int[t.length];

		for (int i = 0; i < t.length; i++) {
			int count = 0;
			for (int j = i + 1; j < t.length; j++) {
				count++;
				if (t[i] < t[j]) {
					break;
				}
			}
			arr[i] = count;
		}
		return arr;
	}

	public boolean stoneGame2(int[] piles) {
		int N = piles.length;

		// dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]].
		int[][] dp = new int[N + 2][N + 2];
		for (int size = 1; size <= N; ++size)
			for (int i = 0; i + size <= N; ++i) {
				int j = i + size - 1;
				int parity = (j + i + N) % 2; // j - i - N; but +x = -x (mod 2)
				if (parity == 1)
					dp[i + 1][j + 1] = Math.max(piles[i] + dp[i + 2][j + 1], piles[j] + dp[i + 1][j]);
				else
					dp[i + 1][j + 1] = Math.min(-piles[i] + dp[i + 2][j + 1], -piles[j] + dp[i + 1][j]);
			}

		return dp[1][N] > 0;
	}

	public boolean stoneGame(int[] piles) {
		if (piles == null || piles.length == 0) {
			return false;
		}
		int sumA = 0, sumL = 0, i = 0, j = piles.length - 1, count = 0;
		while (i < j) {
			int val = 0;
			if (piles[i] > piles[j]) {
				val = piles[i];
				i++;
			} else {
				val = piles[j];
				j--;
			}
			if (count % 2 == 0) {
				sumA += val;
			} else {
				sumL += val;
			}
			count++;
		}

		return sumA > sumL ? true : false;
	}

	public int[][] reconstructQueue(int[][] people) {

		return null;
	}

	public ListNode sortList(ListNode head) {

		return null;
	}

	public int maxProduct(int[] nums) {
		// Input: [2,3,-2,4]
		// Input: [-2,0,-1]
		// [2,-5,-2,-4,3]

		if (nums == null || nums.length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int sum = nums[0];
		if (max < sum) {
			max = sum;
		}
		for (int i = 1; i < nums.length; i++) {
			if (max < nums[i]) {
				max = nums[i];
			}
			sum *= nums[i];
			if (max < sum) {
				max = sum;
			}
		}

//		for (int i = 0; i < nums.length; i++) {
//			if (max < nums[i]) {
//				max = nums[i];
//			}
//			int sum = nums[i];
//			for (int j = i + 1; j < nums.length; j++) {
//				sum *= nums[j];
//				if (max < sum) {
//					max = sum;
//				}
//			}
//		}
		return max;
	}

	public List<List<Integer>> permute(int[] nums) {

		List<List<Integer>> res = new ArrayList<>();
		directedPermutations(0, nums, res);
		return res;

	}

	public void directedPermutations(int i, int[] nums, List<List<Integer>> res) {
		if (i == nums.length - 1) {
			List<Integer> r = new ArrayList<>();
			for (int n : nums) {
				r.add(n);
			}
			res.add(r);
			return;
		}

		for (int j = i; j < nums.length; ++j) {
			nums = swap(nums, i, j);
			directedPermutations(i + 1, nums, res);
			nums = swap(nums, i, j);
		}
	}

	public int[] swap(int[] nums, int i, int j) {
		int temp = nums[i];
		nums[i] = nums[j];
		nums[j] = temp;
		return nums;
	}

	public void wiggleSort(int[] nums) {

	}

	public List<String> findWords(char[][] board, String[] words) {
		List<String> res = new ArrayList<>();
		TrieNode root = buildTrie(words);
		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[0].length; j++) {
				dfs(board, i, j, root, res);
			}
		}
		return res;
	}

	public void dfs(char[][] board, int i, int j, TrieNode tn, List<String> res) {
		char c = board[i][j];
		if (c == '#' || tn.next[c - 'a'] == null)
			return; // pruning
		tn = tn.next[c - 'a'];
		if (tn.word != null) { // found one
			res.add(tn.word);

			tn.word = null;
		}
		board[i][j] = '#'; // mark visited
		if (i > 0)
			dfs(board, i - 1, j, tn, res);
		if (j > 0)
			dfs(board, i, j - 1, tn, res);
		if (i < board.length - 1)
			dfs(board, i + 1, j, tn, res);
		if (j < board[0].length - 1)
			dfs(board, i, j + 1, tn, res);
		board[i][j] = c; // backtrack
	}

	public TrieNode buildTrie(String[] words) {
		TrieNode root = new TrieNode();
		for (String w : words) {
			TrieNode p = root;
			for (char c : w.toCharArray()) {
				int i = c - 'a';
				if (p.next[i] == null)
					p.next[i] = new TrieNode();
				p = p.next[i];
			}
			p.word = w;
		}
		return root;
	}

	static class TrieNode {
		TrieNode[] next = new TrieNode[26];
		String word;
	}

	public List<String> findWords1(char[][] board, String[] words) {

		List<String> result = new ArrayList<>();
		for (int i = 0; i < words.length; i++) {
			boolean found = false;
			for (int j = 0; j < board.length; j++) {
				for (int k = 0; k < board[j].length; k++) {
					if (words[i].charAt(0) == board[j][k]) {
						found = dfs(board, j, k, words[i], 0);
					}
				}
				if (found) {
					result.add(words[i]);
					break;
				}
			}
		}
		return result;
	}

	private boolean dfs(char[][] board, int i, int j, String word, int currIndex) {
		if (i > board.length - 1 || i < 0 || j < 0 || j > board[i].length || currIndex > word.length() - 1) {
			return false;

		}
		if (word.equals("eat")) {
			System.out.println(word + "-----------" + word.length() + "------    " + currIndex);
		}
		boolean found = false;
		if (board[i][j] == word.charAt(currIndex)) {
			found = dfs(board, i + 1, j, word, currIndex + 1) || dfs(board, i - 1, j, word, currIndex + 1)
					|| dfs(board, i, j - 1, word, currIndex + 1) || dfs(board, i, j + 1, word, currIndex + 1);
		}
		return found;
	}

	public TreeNode constructMaximumBinaryTree(int[] nums) {
		if (nums == null || nums.length == 0) {
			return null;
		}
		return construct(nums, 0, nums.length - 1);
	}

	private TreeNode construct(int[] nums, int start, int end) {
		if (start == end) {
			return new TreeNode(nums[start]);
		}
		if (start <= end) {
			int maxIndex = maxElementIndex(nums, start, end);
			TreeNode root = new TreeNode(nums[maxIndex]);
			// repeat from left and right
			root.left = construct(nums, start, maxIndex - 1);
			root.right = construct(nums, maxIndex + 1, end);
			return root;
		}
		return null;
	}

	private int maxElementIndex(int[] nums, int start, int end) {

		int maxIndex = Integer.MIN_VALUE;
		for (int i = start; i <= end; i++) {
			if (maxIndex < nums[i]) {
				maxIndex = i;
			}
		}
		return maxIndex;
	}

	public void solve(char[][] board) {
		if (board == null || board.length == 0)
			return;

		int row = board.length;
		int col = board[0].length;

		for (int i = 0; i < row; i++) {
			if (board[i][0] == 'O')
				boundaryDFS(board, i, 0);
			if (board[i][col - 1] == 'O')
				boundaryDFS(board, i, col - 1);
		}
		for (int j = 0; j < col; j++) {
			if (board[0][j] == 'O')
				boundaryDFS(board, 0, j);
			if (board[row - 1][j] == 'O')
				boundaryDFS(board, row - 1, j);
		}

		for (int i = 0; i < board.length; i++) {
			for (int j = 0; j < board[i].length; j++) {
				if (board[i][j] == '0') {
					board[i][j] = 'X';
				}
				if (board[i][j] == '*') {
					board[i][j] = 'O';
				}
			}
		}
		System.out.println(board[0][0]);
	}

	private void boundaryDFS(char[][] board, int i, int j) {

		if (i > board.length - 1 || i < 0 || j < 0 || j > board[i].length) {
			return;

		}
		if (board[i][j] == 'O') {
			board[i][j] = '*';
		}
		if (i < board.length - 1 && board[i + 1][j] == '0') {
			boundaryDFS(board, i + 1, j);
		}
		if (i > 0 && board[i - 1][j] == '0') {
			boundaryDFS(board, i - 1, j);
		}
		if (j > 0 && board[i][j - 1] == '0') {
			boundaryDFS(board, i, j - 1);
		}
		if (j < board[0].length - 1 && board[i][j + 1] == '0') {
			boundaryDFS(board, i, j + 1);
		}
		return;

	}

	private boolean checkAdjacentBoarders(char[][] grid, int i, int j) {
		if (i - 1 < 0 || i + 1 >= grid.length || j - 1 < 0 || j + 1 >= grid[i].length) {
			return false;
		}
		if (grid[i + 1][j] == 'O' || grid[i - 1][j] == 'O' || grid[i][j - 1] == 'O' || grid[i][j + 1] == 'O')
			return true;

		return false;
	}

	public int distributeCoins(TreeNode root) {
		ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();

		return 0;
	}

	public int getMaximumGold(int[][] grid) {

		int max = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j] == 0)
					continue;
				int maxGold = maxGold(grid, i, j);
				max = max < maxGold ? maxGold : max;
			}
		}
		return max;
	}

	private int maxGold(int[][] arr, int row, int col) {

		if (row < 0 || col < 0 || row == arr.length || col == arr[0].length || arr[row][col] == 0) {
			return 0;
		}
		int collect = 0;

		collect += arr[row][col];

		int store = arr[row][col];
		arr[row][col] = 0;
		int collect1 = maxGold(arr, row - 1, col);
		int collect2 = maxGold(arr, row + 1, col);
		int collect3 = maxGold(arr, row, col + 1);
		int collect4 = maxGold(arr, row, col - 1);
		arr[row][col] = store;

		return collect + Math.max(collect1, Math.max(collect2, Math.max(collect3, collect4)));

	}

	private boolean checkAdj(int[][] grid, int i, int j) {

		if (i + 1 < grid.length) {
			if (grid[i + 1][j] != 0) {
				return true;
			}
		}
		if (i - 1 >= 0) {
			if (grid[i - 1][j] != 0) {
				return true;
			}
		}
		if (j + 1 < grid[i].length) {
			if (grid[i][j + 1] != 0) {
				return true;
			}
		}
		if (j - 1 >= 0) {
			if (grid[i][j - 1] != 0) {
				return true;
			}
		}
		return false;
	}

	public boolean checkSubarraySum(int[] nums, int k) {

		if (nums == null || nums.length == 0) {
			return false;
		}
		for (int i = 0; i < nums.length; i++) {
			int sum = 0;
			for (int j = i + 1; j < nums.length; j++) {
				sum += nums[i] + nums[j];
				if (sum % k == 0) {
					return true;
				}
			}
		}
		return false;
	}

	public int compareVersion(String version1, String version2) {
		if (version1 == null || version1.length() == 0) {
			return -1;
		}

		if (version2 == null || version2.length() == 0) {
			return 1;
		}

		String[] ver1 = version1.split("\\.");
		String[] ver2 = version2.split("\\.");
		System.out.println("Len" + ver1.length);

		if (ver1.length < ver2.length) {
			String[] ver = new String[ver2.length];
			for (int i = 0; i < ver.length; i++) {
				if (i < ver1.length) {
					ver[i] = ver1[i];
				} else {
					ver[i] = "0";
				}
			}
			ver1 = ver;
		} else if (ver1.length > ver2.length) {
			String[] ver = new String[ver1.length];
			for (int i = 0; i < ver.length; i++) {
				if (i < ver2.length) {
					ver[i] = ver2[i];
				} else {
					ver[i] = "0";
				}
			}
			ver2 = ver;
		}

		for (int i = 0; i < ver2.length; i++) {
			int val1 = Integer.parseInt(ver1[i]);
			int val2 = Integer.parseInt(ver2[i]);
			System.out.println("v1: " + val1 + " val2 :" + val2);
			if (val1 > val2) {
				return 1;
			} else if (val1 < val2) {
				return -1;
			}
		}

		return 0;
	}

	/*
	 * 
	 * 
	 * Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2),
	 * rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob
	 * = 2 + 9 + 1 = 12.
	 * 
	 */
	public int rob(int[] nums) {

		return 0;
	}

	public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
		boolean contains = false;
		for (int i = 0; i < nums.length; i++) {
			for (int j = i + 1; j < nums.length; j++) {
				if (Math.abs(nums[i] - nums[j]) <= t && j - i <= k) {
					contains = true;
				}
			}
		}

		return contains;
	}

	/*
	 * 
	 * Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3]
	 * ]
	 */
	public List<List<Integer>> combinationSum(int[] candidates, int target) {
		List<List<Integer>> result = new ArrayList<>();
		List<Integer> current = new ArrayList<>();
		findCombinations(result, current, candidates, 0, target, 0);
		return result;
	}

	private void findCombinations(List<List<Integer>> result, List<Integer> current, int[] candidates, int start,
			int target, int sum) {

		if (sum > target)
			return;
		if (sum == target) {
			result.add(new ArrayList<>(current));
			return;
		}
		for (int i = start; i < candidates.length; i++) {
			current.add(candidates[i]);
			findCombinations(result, current, candidates, i, target, sum + candidates[i]);
			current.remove(current.size() - 1);
		}
	}

	protected void backtrack(int remain, int k, LinkedList<Integer> comb, int next_start, List<List<Integer>> results) {

		if (remain == 0 && comb.size() == k) {
			// Note: it's important to make a deep copy here.
			results.add(new ArrayList<Integer>(comb));
			return;
		} else if (remain < 0 || comb.size() == k) {
			// Exceed the scope, no need to explore further.
			return;
		}

		// Iterate through the reduced list of candidates.
		for (int i = next_start; i < 9; ++i) {
			comb.add(i + 1);
			this.backtrack(remain - i - 1, k, comb, i + 1, results);
			comb.removeLast();
		}
	}

	private void combinations(int index, int size, int target, int[] vals, List<Integer> comb,
			List<List<Integer>> result) {

		if (target == 0 && size == comb.size()) {
			result.add(new ArrayList<>(comb));
		} else if (target < 0 || size == comb.size()) {
			return;
		}
		for (int i = index; i < vals.length; i++) {
			comb.add(vals[i]);
			combinations(i + 1, size, target - vals[i], vals, comb, result);
			comb.remove(comb.size() - 1);
		}

	}

	public List<List<Integer>> combinationSum3(int k, int n) {
		List<List<Integer>> result = new ArrayList<List<Integer>>();
		List<Integer> comb = new LinkedList<Integer>();
		int[] vals = new int[9];
		for (int i = 0; i < vals.length; i++) {
			vals[i] = i + 1;
		}
		combinations(0, k, n, vals, comb, result);
		return result;
	}

	public int regionsBySlashes(String[] grid) {

		return 0;
	}

	public boolean wordPattern(String pattern, String str) {

		return false;
	}

	public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {

		Set<Integer> set = new HashSet<>();
		for (int i : to_delete) {
			set.add(i);
		}
		deleteNode(root, set, true);
		return null;
		// return result;
	}

	private void deleteNode(TreeNode root, Set<Integer> set, boolean mathced) {
		if (root == null) {
			return;
		}
		if (set.contains(root.val)) {
			deleteNode(root.left, set, true);
			deleteNode(root.right, set, true);
		} else {
			deleteNode(root.left, set, false);
			deleteNode(root.right, set, false);
			if (mathced) {
				// result.add(root);
			}
		}
		return;
	}

	private void delete(TreeNode root, int val) {
		if (root == null) {
			return;
		}
		System.out.println("checking value for : " + val);
		if (root.left != null && root.left.val == val) {
			if (root.left.left == null && root.left.right == null) {
				root.left = null;
			} else {
				root.left = root.left.left;
				root.left.left = null;
			}
			return;
		}
		if (root.right != null && root.right.val == val) {
			if (root.right.left == null && root.right.right == null) {
				root.right = null;
			} else {
				root.right = root.right.right;
				root.right.right = null;
			}
			return;
		}
		delete(root.left, val);
		delete(root.right, val);

	}

	public boolean repeatedSubstringPattern(String s) {
		int start = 0;
		for (int i = 1; i < s.length(); i++) {

		}
		return false;
	}

//		String[] words = { "a", "b", "ba", "bca", "bda", "bdca" };

	public boolean wordBreak(String s, List<String> wordDict) {

		// Input: s = "apple pen apple", wordDict = ["apple", "pen"] true

		return false;
	}

	public int longestPalindromeSubseq12(String s) {
		int n = s.length();
		int[][] dp = new int[n][n];

		for (int i = 0; i < s.length(); i++) {
			for (int j = 0; j < s.length(); j++) {
				if (i == j) {
					dp[i][j] = 1;
				}
				if (i + 1 < s.length() && j - 1 >= 0 && s.charAt(i) == s.charAt(j)) {
					dp[i][j] = 2 + dp[i + 1][j - 1];
				} else if (i + 1 < s.length() && j - 1 >= 0) {
					dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
				}
			}
		}

		return dp[s.length() - 1][s.length() - 1];
		// return calMaxPalindromeSubseq(s, 0, s.length() - 1);
	}

	public int longestPalindromeSubseq(String s) {
		int[][] dp = new int[s.length()][s.length()];
		return calMaxPalindromeSubseq(s, 0, s.length() - 1, dp);
	}

	private int calMaxPalindromeSubseq(String str, int start, int end, int[][] dp) {
		if (start > end) {
			return 0;
		}
		if (start == end) {
			return 1;
		}

		if (dp[start][end] == 0) {
			if (str.charAt(start) == str.charAt(end)) {
				dp[start][end] = 2 + calMaxPalindromeSubseq(str, start + 1, end - 1, dp);
			} else {
				dp[start][end] = Math.max(calMaxPalindromeSubseq(str, start, end - 1, dp),
						calMaxPalindromeSubseq(str, start + 1, end, dp));
			}
		}
		return dp[start][end];
	}

	public int longestStrChain(String[] words) {
		int max = 0;
		int[] dp = new int[words.length];
		Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
		Arrays.fill(dp, 1);
		for (int i = 0; i < dp.length; i++) {
			for (int j = i - 1; j >= 0; j--) {
				boolean flag = true;
				if (words[j].length() + 1 == words[i].length() && compare(words[j], words[i])) {
					flag = false;
				}
				if (!flag && dp[j] + 1 > dp[i]) {
					dp[i] = dp[j] + 1;
				}
			}
			if (max < dp[i]) {
				max = dp[i];
			}
		}

		return max;
	}

	private boolean compare(String str, String next) {

		char[] cs1 = str.toCharArray();
		char[] cs2 = next.toCharArray();
		int length1 = cs1.length;
		int length2 = cs2.length;

		int i = 0, j = 0;
		boolean foundDiff = false;

		while (i < length1 && j < length2) {
			if (cs1[i] != cs2[j]) {
				if (foundDiff) {
					return false;
				} else {
					j++;
					foundDiff = true;
				}
			} else {
				i++;
				j++;
			}
		}

		return true;
	}

	Map<Integer, Integer> map = new HashMap<>();
	int res = 1;

	public int widthOfBinaryTree(TreeNode root) {
		calculateWidth(root, 0, 1);
		return res;
	}

	private void calculateWidth(TreeNode root, int index, int level) {
		if (root == null)
			return;
		if (!map1.containsKey(level)) {
			map1.put(level, index);
		} else {
			res = Math.max(res, index - map1.get(level) + 1);
		}
		calculateWidth(root.left, level + 1, 2 * index);
		calculateWidth(root.right, level + 1, 2 * index + 1);
	}

	public TreeNode insertIntoBST(TreeNode root, int val) {
		if (root == null) {
			return null;
		}
		insert(root, val);
		return root;
	}

	private void insert(TreeNode root, int val) {
		if (root == null) {
			return;
		}
		if (root.left == null && root.right == null) {
			TreeNode node = new TreeNode(val);
			if (root.val > val) {
				root.left = node;
			} else {
				root.right = node;
			}
			return;
		}

		if (root.val > val) {
			if (root.left == null) {
				TreeNode node = new TreeNode(val);
				root.left = node;
				return;
			} else {
				insert(root.left, val);
			}
		} else {
			if (root.right == null) {
				TreeNode node = new TreeNode(val);
				root.right = node;
				return;
			} else {
				insert(root.right, val);
			}
		}

	}

	int[] memo;
	Set<Integer> days = new HashSet<>();
	int[] costs;

	public int mincostTickets(int[] days, int[] costs) {
		this.costs = costs;
		this.memo = new int[366];
		for (int day : days) {
			this.days.add(day);
		}
		return minimumPriceCalculation(1);
	}

	private int minimumPriceCalculation(int i) {
		if (i > 366) {
			return 0;
		}
		if (memo[i] != 0) {
			return memo[i];
		}
		int ans = 0;
		if (days.contains(i)) {
			ans = Math.min(minimumPriceCalculation(i + 1) + costs[0], minimumPriceCalculation(i + 7) + costs[1]);
			ans = Math.min(ans, minimumPriceCalculation(i + 30) + costs[2]);
		} else {
			ans = minimumPriceCalculation(i + 1);
		}
		memo[i] = ans;

		return ans;
	}

	int sum = 0;

	public int sumOfLeftLeaves(TreeNode root) {
		countLeaves(root);
		return sum;
	}

	private void countLeaves(TreeNode root) {
		if (root == null) {
			return;
		}
		if (root.left != null) {
			sum += root.left.val;
		}
		countLeaves(root.left);
		countLeaves(root.right);

	}

	public boolean flipEquiv(TreeNode root1, TreeNode root2) {
		return checkEquiv(root1, root2);
	}

	private boolean checkEquiv(TreeNode root1, TreeNode root2) {
		if (root1 == null && root2 == null) {
			return true;
		}
		if (root1.val == root2.val) {
			return true;
		}

		return (checkEquiv(root1.left, root2.left) && checkEquiv(root1.right, root2.right))
				|| (checkEquiv(root1.left, root2.right) && checkEquiv(root1.right, root2.left));
	}

	public int eggDrop(int eggs, int floors) {

		if (eggs == 1 || eggs == 0) {
			return floors;
		}
		if (floors == 1) {
			return eggs;
		}
		int min = Integer.MAX_VALUE;
		for (int i = 1; i <= floors; i++) {
			int res = Math.max(eggDrop(eggs - 1, i - 1), eggDrop(eggs, floors - i));
			if (res < min) {
				min = res;
			}
		}

		return 1 + min;

	}

	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		if (root == null) {
			return null;
		}
		if (root.val == p.val || root.val == q.val) {
			return root;
		}
		TreeNode left = lowestCommonAncestor(root.left, p, q);
		TreeNode right = lowestCommonAncestor(root.right, p, q);
		if (left != null && right != null) {
			return root;
		}
		return left == null ? right : left;
	}

	// 2
	int max = Integer.MIN_VALUE;
	List<Integer> list = new ArrayList<>();

	public int solution(Tree T) {
		// write your code in Java SE 8
		countTree(T);
		return max;
	}

	public void countTree(Tree root) {
		if (root == null) {
			return;
		}
		list.add(root.x);
		countTree(root.l);
		countTree(root.r);
		Set<Integer> set = new HashSet<>();
		for (int i = 0; i < list.size(); i++) {
			if (set.contains(list.get(i))) {
				set.add(list.get(i));
			}
		}
		if (set.size() > max) {
			max = set.size();
		}
		list.remove(list.size() - 1);

	}

	public int solution(String A, String B) {
		// write your code in Java SE 8
		if (A == null || A.length() == 0 || B == null || B.length() == 0) {
			return 0;
		}
		if (A.length() != B.length()) {
			return 0;
		}
		Map<Character, Integer> map = new HashMap<>();
		map.put(new Character('A'), 14);
		map.put(new Character('K'), 13);
		map.put(new Character('Q'), 12);
		map.put(new Character('J'), 11);
		map.put(new Character('T'), 10);
		map.put(new Character('9'), 9);
		map.put(new Character('8'), 8);
		map.put(new Character('7'), 7);
		map.put(new Character('6'), 6);
		map.put(new Character('5'), 5);
		map.put(new Character('4'), 4);
		map.put(new Character('3'), 3);
		map.put(new Character('2'), 2);

		int count = 0;
		for (int i = 0; i < A.length(); i++) {
			if (map.get(A.charAt(i)) > map.get(B.charAt(i))) {
				count++;
			}
		}

		return count;
	}

	public int solution(int[] A) {
		// write your code in Java SE 8
		int len = A.length;
		Set<Integer> set = new HashSet<>();
		for (int a : A) {
			set.add(a);
		}
		for (int i = 1; i <= len + 1; i++) {
			if (!set.contains(i)) {
				return i;
			}
		}
		return 0;
	}

	public int eraseOverlapIntervals(int[][] intervals) {
		if (intervals == null || intervals.length == 0) {
			return 0;
		}
		int count = 0;

		for (int i = 0; i + 1 < intervals.length; i++) {
			if (intervals[i][0] < intervals[i + 1][0] && intervals[i][1] < intervals[i + 1][1]) {

			} else {

				intervals[i] = null;
			}
		}

		for (int i = 0; i < intervals.length; i++) {
			if (intervals[i] == null) {
				count++;
			}
		}
		return count;

	}

	/*
	 * equations = [ ["a", "b"], ["b", "c"] ], values = [2.0, 3.0], queries = [
	 * ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ].
	 */
	public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {

		return null;
	}

	public int longestPalindrome1(String s) {
		// 2147483647

		if (s == null || s.length() == 0 || s.length() > 1010) {
			return 0;
		}
		Map<Character, Integer> map = new HashMap<>();
		for (int i = 0; i < s.length(); i++) {
			Integer val = map.get(s.charAt(i));
			if (val == null) {
				val = 1;
			} else {
				val += 1;
			}
			map.put(s.charAt(i), val);
		}
		int ans = 0;
		for (Map.Entry<Character, Integer> entry : map.entrySet()) {
			int v = entry.getValue();
			ans += v / 2 * 2;
			if (ans % 2 == 0 && v % 2 == 1)
				ans++;
		}
		return ans;

	}

	public List<String> subs(String str, int n) {
		List<String> list = new ArrayList<>();
		for (int i = 0; (i + n - 1) < str.length(); i++) {
			list.add(str.substring(i, n + i));
		}
		return list;
	}

	public int numMagicSquaresInside(int[][] grid) {

		if (grid == null || grid.length == 0) {
			return 0;
		}
		int count = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j + 2 < grid[i].length; j++) {
				grid[i][j] = grid[i][j] + grid[i][j + 1] + grid[i][j + 2];
			}
		}
		for (int i = 0; i < grid.length; i++) {
			boolean flag = true;
			for (int j = i + 1; j + 1 < grid[i].length; j++) {
				if (grid[i][j] != grid[i][j + 1]) {
					flag = false;
				}
			}
			if (flag) {
				count++;
			}
		}
		for (int j = 0; j < grid[0].length; j++) {
			boolean flag = true;
			int val = grid[j][0];
			for (int i = j + 1; i < grid.length; i++) {
				if (val != grid[i][j]) {
					flag = false;
				}
			}
			if (flag) {
				count++;
			}
		}

		int c = 0;
		int size = grid.length + grid[0].length - 1;
		int i = 0, j = 0;
		// There can be at most m + n -1 diagonals to be printed
		while (c < size) {
			// Start printing diagonals from i and j
			int val = grid[i][j];
			checkDiagonal(i, j, grid, val);
			if (i < grid.length - 1) {
				// We increment row index until we reach the max number of rows
				i++;
			} else if (j < grid[0].length - 1) {
				// We are at maximum index of row; so its time to increment col index
				// We increment column index until we reach the max number of columns
				j++;
			}
			c++;
		}

		return count;

	}

	private boolean checkDiagonal(int i, int j, int[][] grid, int val) {
		while (i >= 0 && j < grid[0].length) {
			if (val != grid[i][j]) {
				return false;
			}
			i--;
			j++;
		}
		return true;
	}

	public int longestStrChain1(String[] words) {
		if (words == null || words.length == 0) {
			return 0;
		}
		if (words.length == 1) {
			return 1;
		}
		int max = Integer.MIN_VALUE;

		for (int i = 0; i < words.length; i++) {
			String str = words[i];
			int count = 0;
			for (int j = i + 1; j < words.length; j++) {
				if (contains(str, words[j])) {
					str = words[j];
					count++;
				}
				if (count > max) {
					max = count;
				}

			}
		}
		return max;
	}

	public boolean contains(String s, String res) {
		if (res.length() < s.length()) {
			return false;
		}
		char[] cs1 = s.toCharArray();
		char[] cs2 = res.toCharArray();
		int length1 = cs1.length;
		int length2 = cs2.length;

		int i = 0, j = 0;
		boolean foundDiff = false;

		while (i < length1 && j < length2) {
			if (cs1[i] != cs2[j]) {
				if (foundDiff) {
					return false;
				} else {
					j++;
					foundDiff = true;
				}
			} else {
				i++;
				j++;
			}
		}

		return true;
	}

	public ListNode partition(ListNode head, int x) {

		// before and after are the two pointers used to create the two list
		// before_head and after_head are used to save the heads of the two lists.
		// All of these are initialized with the dummy nodes created.
		ListNode before_head = new ListNode(0);
		ListNode before = before_head;
		ListNode after_head = new ListNode(0);
		ListNode after = after_head;

		while (head != null) {

			// If the original list node is lesser than the given x,
			// assign it to the before list.
			if (head.val < x) {
				before.next = head;
				before = before.next;
			} else {
				// If the original list node is greater or equal to the given x,
				// assign it to the after list.
				after.next = head;
				after = after.next;
			}

			// move ahead in the original list
			head = head.next;
		}

		// Last node of "after" list would also be ending node of the reformed list
		after.next = null;

		// Once all the nodes are correctly assigned to the two lists,
		// combine them to form a single list which would be returned.
		before.next = after_head.next;

		return before_head.next;
	}

	public List<Integer> getRow(int rowIndex) {
		List<Integer> list = new ArrayList<>();
		list.add(1);
		if (rowIndex == 0) {
			return list;
		}
		list.add(1);
		for (int i = 2; i <= rowIndex; i++) {
			list = addIntoList(list, i);
		}
		return list;

	}

	public List<Integer> addIntoList(List<Integer> list, int index) {
		List<Integer> result = new ArrayList<>();
		result.add(list.get(0));
		for (int i = 0; i + 1 < index; i++) {
			result.add((list.get(i) + list.get(i + 1)));
		}
		result.add(list.get(list.size() - 1));

		return result;
	}

	public int numMatchingSubseq(String s, String[] t) {
		int result = 0;
		if (s == null || s.length() == 0) {
			return 0;
		}
		if (s.length() > 50000) {
			return 0;
		}
		if (t == null || t.length == 0) {
			return 0;
		}
		for (int i = 0; i < t.length; i++) {
			int count = 0;
			String str = t[i];
			for (int j = 0; j < s.length(); j++) {
				if (count < str.length() && str.charAt(count) == s.charAt(j)) {
					count++;
				}
			}
			if (count == str.length()) {
				result++;
			}

		}

		return result;
	}

	public int minFallingPathSum(int[][] A) {
		for (int i = 0; i < A.length; i++) {
			Arrays.sort(A[i]);
		}
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < A.length; i++) {
			list.add(A[i][0]);
		}
		int sum = 0;
		for (int i = 0; i < list.size(); i++) {
			sum = sum + list.get(i);
		}

		return sum;
	}

	public int orangesRotting(int[][] grid) {
		boolean changed = false;
		int no = 2;
		while (true) {
			for (int i = 0; i < grid.length; i++) {
				for (int j = 0; j < grid[i].length; j++) {

					// Rot all other oranges present at
					// (i+1, j), (i, j-1), (i, j+1), (i-1, j)
					if (grid[i][j] == no) {
						if (isSafe(grid, i + 1, j) && grid[i + 1][j] == 1) {
							grid[i + 1][j] = grid[i][j] + 1;
							changed = true;
						}
						if (isSafe(grid, i, j + 1) && grid[i][j + 1] == 1) {
							grid[i][j + 1] = grid[i][j] + 1;
							changed = true;
						}
						if (isSafe(grid, i - 1, j) && grid[i - 1][j] == 1) {
							grid[i - 1][j] = grid[i][j] + 1;
							changed = true;
						}
						if (isSafe(grid, i, j - 1) && grid[i][j - 1] == 1) {
							grid[i][j - 1] = grid[i][j] + 1;
							changed = true;
						}
					}
				}
			}

			// if no rotten orange found it means all
			// oranges rottened now
			if (!changed)
				break;
			changed = false;
			no++;
		}

		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {

				// if any orange is found to be
				// not rotten then ans is not possible
				if (grid[i][j] == 1)
					return -1;
			}
		}

		// Because initial value for a rotten
		// orange was 2
		return no - 2;
	}

	boolean isSafe(int[][] grid, int i, int j) {
		if (i >= 0 && i < grid.length && j >= 0 && j < grid[i].length)
			return true;
		return false;
	}

	public int pathSum(TreeNode root, int sum) {
		List<List<Integer>> list = new ArrayList<>();
		findPaths(root, sum, new ArrayList<>(), list);
		return list.size();
	}

	private void findPaths(TreeNode root, int sum, ArrayList<Integer> currentList, List<List<Integer>> list) {
		if (root == null) {
			return;
		}
		currentList.add(root.val);
		if (root.val == sum && root.left == null && root.right == null) {
			list.add(currentList);
			return;
		}
		findPaths(root.left, sum - root.val, new ArrayList<>(currentList), list);
		findPaths(root.left, sum - root.val, new ArrayList<>(currentList), list);
	}

	public int numDecodings(String s) {
		if (s == null || s.length() == 0) {
			return 0;
		}
		String str = "";
		for (int i = 0; i < s.length(); i++) {
			if (s.charAt(i) != '0') {
				str += s.charAt(i);
			}
		}
		s = str;
		if (s.equals("0")) {
			return 0;
		}
		if (s.length() == 1) {
			return 1;
		}
		int dp[] = new int[s.length() + 1];
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i < dp.length; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[dp.length - 1];
	}

	public boolean isValidBST1(TreeNode root) {
		if (root == null) {
			return true;
		}
		if (root.left != null && root.left.val > root.val) {
			return false;
		}
		if (root.right != null && root.right.val < root.val) {
			return false;
		}
		if (!isValidBST(root.left)) {
			return false;
		}
		if (!isValidBST(root.right)) {
			return false;
		}

		return false;
	}

	private boolean checkBST(TreeNode root) {

		if (root == null) {
			return true;
		}
		if (root.left != null && root.left.val > root.val) {
			return false;
		}
		if (root.right != null && root.right.val < root.val) {
			return false;
		}
		if (!checkBST(root.left)) {
			return false;
		}
		if (!checkBST(root.right)) {
			return false;
		}

		return true;
	}

	public List<List<Integer>> levelOrder(TreeNode root) {
		List<List<Integer>> result = new ArrayList<>();
		Queue<TreeNode> queue = new LinkedList<>();
		queue.add(root);
		while (queue.size() > 0) {
			List<Integer> list = new ArrayList<>();
			Queue<TreeNode> node = new LinkedList<>();
			while (queue.size() > 0) {
				TreeNode tree = queue.poll();
				list.add(tree.val);
				if (tree.left != null) {
					node.add(tree.left);
				}
				if (tree.right != null) {
					node.add(tree.right);
				}
			}
			result.add(list);
			queue = node;
		}
		return result;
	}

	// 7 ,3,
	public List<List<Integer>> levelOrder1(TreeNode root) {
		Queue<TreeNode> q = new LinkedList<TreeNode>();
		List<List<Integer>> fin = new ArrayList<List<Integer>>();

		if (root != null) {
			q.add(root);
		}
		while (q.size() > 0) {
			List<Integer> l = new ArrayList<Integer>();
			Queue<TreeNode> nodes = new LinkedList<TreeNode>();
			while (q.size() > 0) {

				TreeNode t = q.poll();
				l.add(t.val);
				if (t.left != null) {
					nodes.add(t.left);
				}
				if (t.right != null) {
					nodes.add(t.right);
				}

			}
			fin.add(l);
			q = nodes;

		}

		return fin;
	}

	public List<Integer> findDuplicates(int[] nums) {
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < nums.length; i++) {
			int val = nums[i];
			if (val < 0) {
				val = -val;
			}
			if (nums[val - 1] < 0) {
				list.add(val);
			} else {
				nums[val - 1] = -nums[val - 1];
			}
		}

		return list;
	}

	public int[] productExceptSelf(int[] nums) {
		if (nums == null || nums.length == 0) {
			return nums;
		}
		int val = 1;
		for (int i = 0; i < nums.length; i++) {
			val *= nums[i];
		}
		for (int i = 0; i < nums.length; i++) {
			nums[i] = val >>> nums[i];
		}

		return nums;
	}

	public int lengthOfLIS(int[] nums) {
		return lengthOfLIS(nums, Integer.MIN_VALUE, 0);
	}

	public int lengthOfLIS(int[] nums, int prev, int count) {
		if (count == nums.length) {
			return 0;
		}
		int taken = 0;
		if (nums[count] > prev) {
			taken = 1 + lengthOfLIS(nums, nums[count], count + 1);
		}
		int notTaken = lengthOfLIS(nums, prev, count);
		return Math.max(taken, notTaken);

	}

	int findMinimumIndex(int[] nums) {
		int min = Integer.MAX_VALUE;
		int index = -1;
		for (int i = 0; i < nums.length; i++) {
			if (min < nums[i]) {
				min = nums[i];
				index = i;
			}
		}
		return index;
	}

	public int lengthOfLIS1(int[] nums) {
		if (nums.length == 0) {
			return 0;
		}
		int[] dp = new int[nums.length];
		Arrays.fill(dp, 1);

		for (int i = 0; i < nums.length; i++) {
			for (int j = 0; j < i; j++) {

				if (nums[j] < nums[i]) {
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
		}
		int lis = dp[0];
		for (int i = 1; i < dp.length; i++) {
			lis = Math.max(lis, dp[i]);
		}

		return lis;
	}

	public String simplifyPath1(String path) {
		Stack<String> stack = new Stack<>();
		String[] arr = path.split("/");
		for (String str : arr) {
			if (str.equals("/") || str.equals(".")) {
				continue;
			} else if (str.equals("..")) {
				stack.pop();
			} else {
				stack.push(str);
			}
		}
		StringBuilder result = new StringBuilder();
		while (!stack.isEmpty()) {
			result.append("/");
			result.append(stack.pop());
		}
		if (result.toString().length() == 0) {
			return "/";
		} else {
			return result.toString();
		}

	}

	public int coinChange(int[] coins, int amount) {
		return changeCoin(0, coins, amount);
	}

	private int changeCoin(int count, int[] coins, int amount) {
		if (amount == 0) {
			return count;
		}

		while (count < coins.length && amount > 0) {
			int maxVal = amount / coins[count];
			int min = Integer.MAX_VALUE;
			for (int i = 0; i <= maxVal; i++) {
				if (amount >= i * coins[count]) {
					int res = changeCoin(count + 1, coins, amount - i * coins[count]);
					if (res > 0) {
						min = Math.min(min, res + i);
					}
				}
			}
			return (min == Integer.MAX_VALUE) ? -1 : min;

		}

		return -1;
	}

	class MyHashSet {
		private List<Integer> list = null;

		/** Initialize your data structure here. */
		public MyHashSet() {
			list = new ArrayList<>();
		}

		public void add(int key) {
			list.add(key);
		}

		public void remove(int key) {
			int index = getIndex(key);
			if (index != -1) {
				list.remove(index);
			}

		}

		private int getIndex(int key) {
			for (int i = 0; i < list.size(); i++) {
				if (list.get(i) == key) {
					return i;
				}

			}
			return -1;
		}

		/** Returns true if this set contains the specified element */
		public boolean contains(int key) {
			return getIndex(key) == -1 ? false : true;
		}
	}

	public boolean canPartition(int[] nums) {

		if (nums == null || nums.length == 0) {
			return false;
		}
		int totalSum = 0;

		for (int i = 0; i < nums.length; i++) {
			totalSum += nums[i];
		}
		if (totalSum % 2 != 0) {
			return false;
		}
		int firstHalfVal = totalSum / 2;

		return isPartitioningUsingDP(nums, nums.length, firstHalfVal);

	}

	public boolean isPartitioningUsingDP(int[] nums, int size, int target) {

		boolean[][] dp = new boolean[size + 1][target + 1];
		dp[0][0] = true;
		for (int i = 1; i < dp.length; i++) {
			dp[0][i] = false;
		}
		for (int i = 1; i < dp[0].length; i++) {
			dp[i][0] = true;
		}
		for (int i = 1; i < dp.length; i++) {
			for (int j = 1; j < dp[i].length; j++) {
				if (j >= nums[i - 1]) {
					dp[i][j] = dp[i - 1][j];
					if (j >= nums[i - 1]) {
						dp[i][j] = (dp[i][j] || dp[i - 1][j - nums[i - 1]]);
					}
				}
			}
		}

		return dp[size][target];
	}

	public boolean searchMatrix1(int[][] matrix, int target) {
		if (matrix.length == 0)
			return false;

		int row = matrix.length;
		int col = matrix[0].length;
		if (matrix[0].length == 0) {
			return false;
		}
		int i = 0, j = col - 1;
		while (i < row && j >= 0) {
			if (matrix[i][j] == target) {
				return true;
			} else if (matrix[i][j] > target) {
				j--;
			} else {
				i++;
			}
		}

		return false;
	}

	public int[][] merge(int[][] intervals) {

		if (intervals == null || intervals.length == 0) {
			return intervals;
		}
		Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

		List<List<Integer>> result = new ArrayList<>();

		for (int i = 0; i + 1 < intervals.length; i++) {
			List<Integer> list = new ArrayList<>();
			boolean flag = false;
			if ((intervals[i][0] >= intervals[i + 1][0]) || (intervals[i][0] >= intervals[i + 1][0])) {
				flag = true;
			}
			if ((intervals[i][1] >= intervals[i + 1][0]) || (intervals[i][1] >= intervals[i + 1][1])) {
				flag = true;
			}
			if (flag) {
				list.add(intervals[i][0]);
				list.add(intervals[i + 1][1]);
			} else {
				list.add(intervals[i][0]);
				list.add(intervals[i][1]);
			}
			result.add(list);
		}

		int[][] res = new int[result.size()][2];

		for (int i = 0; i < res.length; i++) {
			res[i][0] = result.get(i).get(0);
			res[i][1] = result.get(i).get(1);
		}
		return res;

	}

	public boolean canPartition1(int[] nums) {

		if (nums == null || nums.length == 0) {
			return false;
		}
		int totalSum = 0;

		for (int i = 0; i < nums.length; i++) {
			totalSum += nums[i];
		}
		if (totalSum % 2 != 0) {
			return false;
		}
		int firstHalfVal = totalSum / 2;
		return isPartitioning(nums, 0, firstHalfVal);
	}

	boolean isPartitioning(int[] nums, int curreIndex, int val) {
		if (curreIndex > nums.length) {
			return false;
		}
		if (val == 0) {
			return true;
		}
		return isPartitioning(nums, curreIndex + 1, val - nums[curreIndex])
				|| isPartitioning(nums, curreIndex + 1, val);
	}

	boolean util(int[] nums, int start, int end, int val, int curr) {
		if (curr > val)
			return false;
		if (curr == val)
			return true;
		if (start >= end)
			return false;
		// 1,2,3,4
		return util(nums, start + 1, end, val, curr + nums[start]) || util(nums, start + 1, end, val, curr);
	}

	public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
		List<List<Integer>> result = new ArrayList<>();
		DFS(graph, 0, graph.length - 1, new ArrayList<>(), result);
		return result;
	}

	private void DFS(int[][] graph, int source, int destination, List<Integer> list, List<List<Integer>> result) {

		if (source == destination) {
			result.add(list);
		}
		list.add(source);
		for (int vertex : graph[source]) {
			List<Integer> copyList = new ArrayList<>(list); // clone the path

			DFS(graph, vertex, destination, list, result);
		}

	}

	public boolean isValid1(String s) {
		int len = s.length();
		char[] values = new char[len];
		int j = 0;
		for (int i = 0; i < len; i++) {
			char c = s.charAt(i);
			if (i == 0 && (c == ')' || c == '}' || c == ']')) {
				return false;
			}
			if (c == '(') {
				values[j++] = ')';
			}
			if (c == '{') {
				values[j++] = '}';
			}
			if (c == '[') {
				values[j++] = ']';
			}
			if (c == ')' && (j == 0 || c != values[--j])) {
				return false;
			}
			if (c == '}' && (j == 0 || c != values[--j])) {
				return false;
			}
			if (c == ']' && (j == 0 || c != values[--j])) {
				return false;
			}
		}
		return j == 0;
	}
}

class AcyclicGraph {

	private int vertices;
	private LinkedList<Integer>[] adj;

	public AcyclicGraph(int v) {
		this.vertices = v;
		adj = new LinkedList[v];
		for (int i = 0; i < v; i++) {
			adj[i] = new LinkedList<Integer>();
		}
	}

	public void addEdges(int v, int e) {
		adj[v].add(e);
	}

	public void BFS(int s) {
		// Mark all the vertices as not visited(By default
		// set as false)
		boolean visited[] = new boolean[vertices];

		// Create a queue for BFS
		LinkedList<Integer> queue = new LinkedList<Integer>();

		// Mark the current node as visited and enqueue it
		visited[s] = true;
		queue.add(s);

		while (!queue.isEmpty()) {
			// Dequeue a vertex from queue and print it
			s = queue.poll();
			System.out.print(s + " ");

			// Get all adjacent vertices of the dequeued vertex s
			// If a adjacent has not been visited, then mark it
			// visited and enqueue it
			Iterator<Integer> i = adj[s].listIterator();
			while (i.hasNext()) {
				int n = i.next();
				if (!visited[n]) {
					visited[n] = true;
					queue.add(n);
				}
			}
		}

	}

	private void DFSUtil(int v, boolean[] isVisited) {
		isVisited[v] = true;
		System.out.print("   " + v);
		Iterator<Integer> list = adj[v].iterator();
		while (list.hasNext()) {
			int val = list.next();
			if (!isVisited[val]) {
				DFSUtil(val, isVisited);
			}
		}

	}

	public void DFS(int s) {
		boolean[] isVisited = new boolean[vertices];
		DFSUtil(s, isVisited);
	}

}

class Codec1 {

	// Encodes a tree to a single string.
	public String serialize(TreeNode root) {
		if (root == null) {
			return null;
		}
		String result = root.val + ",";
		result = getString(root, result);
		return result;
	}

	private String getString(TreeNode root, String result) {
		if (root == null) {
			return result;
		}
		if (root.left == null) {
			result += null + ",";
		} else {
			result += root.left.val + ",";
		}
		if (root.right == null) {
			result += null + ",";

		} else {
			result += root.right.val + ",";
		}
		result = getString(root.left, result);
		result = getString(root.right, result);

		return result;
	}

	// Decodes your encoded data to tree.
	public TreeNode deserialize(String data) {
		String[] str = data.split(",");
		TreeNode root = new TreeNode(Integer.parseInt(str[0]));
		return getNode(root, str, 1);
	}

	private TreeNode getNode(TreeNode root, String[] str, int index) {
		if (index >= str.length || root == null) {
			return root;
		}
		if (!str[index].equals("null")) {
			root.left = new TreeNode(Integer.parseInt(str[index]));
		} else {
			root.left = null;
		}
		index++;
		if (!str[index].equals("null")) {
			root.right = new TreeNode(Integer.parseInt(str[index]));
		} else {
			root.right = null;
		}
		index++;

		getNode(root.left, str, index);
		getNode(root.right, str, index);
		return root;

	}

}

class CombinationIterator {
	List<String> list = new ArrayList<>();
	String characters;
	int combinationLength;
	int iter;

	public CombinationIterator(String characters, int combinationLength) {
		this.characters = characters;
		this.combinationLength = combinationLength;
		this.iter = 0;
		add();
	}

	private void add() {
		for (int i = 0; (i + combinationLength - 1) < characters.length(); i++) {
			list.add(characters.substring(i, combinationLength));
		}
	}

	public String next() {
		return list.get(iter++);
	}

	public boolean hasNext() {
		if (iter > list.size() - 1) {
			return false;
		}
		return true;
	}
}

class BSTIterator {
	List<Integer> list;
	int index;

	public BSTIterator(TreeNode root) {
		this.index = 0;
		list = new ArrayList<>();
		add(root, list);
	}

	private void add(TreeNode root, List<Integer> list) {
		if (root == null) {
			return;
		}
		add(root.left, list);
		list.add(root.val);
		add(root.right, list);

	}

	/** @return the next smallest number */
	public int next() {
		return list.get(this.index++);
	}

	/** @return whether we have a next smallest number */
	public boolean hasNext() {
		if (this.index < this.list.size())
			return true;
		return false;

	}
}

class MyHashSet {

	private final int MAX_VALUE = 1000000;
	private final int ARRAY_SIZE = 100;
	private List<List<Integer>> parentList;

	public MyHashSet() {
		parentList = new ArrayList<>(ARRAY_SIZE);
		for (int i = 0; i < ARRAY_SIZE; i++) {
			parentList.add(null);
		}
	}

	public void add(int key) {
		int index = key % ARRAY_SIZE;
		List<Integer> childList = parentList.get(index);
		if (childList == null) {
			List<Integer> list = new LinkedList<>();
			list.add(key);
			parentList.set(index, list);
		} else {
			if (!childList.contains(key)) {
				childList.add(key);
			}
		}
	}

	public void remove(int key) {
		int index = key % ARRAY_SIZE;
		List<Integer> childList = parentList.get(index);
		if (childList != null) {
			childList.remove(Integer.valueOf(key));
		}
	}

	public boolean contains(int key) {
		int index = key % ARRAY_SIZE;
		List<Integer> childList = parentList.get(index);
		return childList != null && childList.contains(key);
	}

}



//class Node {
//    int val;
//    Node next;
//    Node random;
//
//    public Node(int val) {
//        this.val = val;
//        this.next = null;
//        this.random = null;
//    }
//};

class Node {
	 int val;
	    Node next;
	    Node random;

	    public Node(int val) {
	        this.val = val;
	        this.next = null;
	        this.random = null;
	    }
};
class Codec {

	// Encodes a tree to a single string.
	public String serialize(TreeNode root) {
		if (root == null)
			return null;
		String result = root.val + ",";
		result = serializeTree(root, result);
		return result;
	}

	public String serializeTree(TreeNode root, String result) {
		if (root == null) {
			return result;
		}
		if (root.left == null) {
			result += null + ",";
		} else {
			result += root.left.val + ",";
		}
		if (root.right == null) {
			result += null + ",";
		} else {
			result += root.right.val + ",";
		}
		result = serializeTree(root.left, result);
		result = serializeTree(root.right, result);
		return result;

	}

	// Decodes your encoded data to tree.
	public TreeNode deserialize(String data) {
		if (data == null || data.length() == 0)
			return null;
		String str[] = data.split(",");
		TreeNode root = new TreeNode(Integer.parseInt(str[0]));
		deserializeTree(root, str, 1);
		return root;
	}

	public void deserializeTree(TreeNode root, String[] data, int index) {
		if (index > data.length - 1 || data[index] == null) {
			return;
		}
		if (!data[index].equals("null")) {
			root.left = new TreeNode(Integer.parseInt(data[index]));
		} else {
			root.left = null;
		}
		index++;
		if (!data[index].equals("null")) {
			root.right = new TreeNode(Integer.parseInt(data[index]));
		} else {
			root.right = null;
		}
		index++;
		deserializeTree(root.left, data, index);
		deserializeTree(root.right, data, index);
	}

}

interface NestedInteger {

	// @return true if this NestedInteger holds a single integer, rather than a
	// nested list.
	public boolean isInteger();

	// @return the single integer that this NestedInteger holds, if it holds a
	// single integer
	// Return null if this NestedInteger holds a nested list
	public Integer getInteger();

	// @return the nested list that this NestedInteger holds, if it holds a nested
	// list
	// Return null if this NestedInteger holds a single integer
	public List<NestedInteger> getList();
}

class NestedIterator implements Iterator<Integer> {

	List<Integer> list = new ArrayList<>();
	int count = 0;

	public NestedIterator(List<NestedInteger> nestedList) {
		addIntoList(nestedList);
	}

	private void addIntoList(List<NestedInteger> nestedList) {
		for (NestedInteger nestedInteger : nestedList) {
			if (nestedInteger.isInteger()) {
				list.add(nestedInteger.getInteger());
			} else {
				addIntoList(nestedInteger.getList());
			}
		}
	}

	@Override
	public Integer next() {
		return list.get(count++);

	}

	@Override
	public boolean hasNext() {
		return this.count < this.list.size() ? true : false;

	}
}
